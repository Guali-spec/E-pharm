Notes â€” Backend : Configuration de base + endpoint /health
1. Objectif de cette Ã©tape

Avant de dÃ©velopper des fonctionnalitÃ©s mÃ©tier, on met en place :

une configuration globale propre

un endpoint technique pour vÃ©rifier que lâ€™API fonctionne

ğŸ‘‰ Cette Ã©tape sert de fondation pour tous les projets backend sÃ©rieux.

2. Validation globale (sÃ©curitÃ© et robustesse)
ProblÃ¨me Ã  rÃ©soudre

Les clients (frontend, API externes) peuvent envoyer des donnÃ©es incorrectes

Sans contrÃ´le, lâ€™API devient fragile et dangereuse

Solution

Utiliser une validation globale qui sâ€™applique Ã  toutes les routes.

ValidationPipe (NestJS)

Un pipe est un filtre exÃ©cutÃ© avant les controllers.

ğŸ‘‰ ValidationPipe :

valide les donnÃ©es entrantes

bloque les donnÃ©es invalides

transforme les types si nÃ©cessaire

Configuration utilisÃ©e
app.useGlobalPipes(
  new ValidationPipe({
    whitelist: true,
    forbidNonWhitelisted: true,
    transform: true,
  }),
);

RÃ´le de chaque option

whitelist: true
â†’ supprime les champs non autorisÃ©s

forbidNonWhitelisted: true
â†’ rejette la requÃªte si des champs inconnus sont prÃ©sents

transform: true
â†’ convertit automatiquement les types (string â†’ number, etc.)

ğŸ‘‰ RÃ©sultat : API stricte, prÃ©visible, sÃ©curisÃ©e

Librairies nÃ©cessaires

class-validator â†’ rÃ¨gles de validation

class-transformer â†’ transformation des types

MÃªme si elles ne sont pas encore utilisÃ©es directement, elles sont indispensables pour la suite.

3. Endpoint /health (standard professionnel)
Ã€ quoi sert /health

Câ€™est un endpoint technique, pas mÃ©tier.

Il permet de rÃ©pondre Ã  la question :

â€œEst-ce que ce service fonctionne ?â€

UtilisÃ© par :

Docker

Kubernetes

monitoring

load balancers

tests automatisÃ©s

CaractÃ©ristiques dâ€™un bon /health

trÃ¨s simple

trÃ¨s rapide

pas de logique mÃ©tier

pas de dÃ©pendance complexe (DB au dÃ©but)

Exemple de rÃ©ponse :

{
  "ok": true,
  "service": "backend",
  "timestamp": "..."
}

4. Organisation par module (NestJS)
Principe

Dans NestJS :

tout est organisÃ© par module

mÃªme une petite fonctionnalitÃ© a son module

Structure typique :

health/
â”œâ”€â”€ health.controller.ts
â””â”€â”€ health.module.ts


ğŸ‘‰ Avantages :

code clair

facile Ã  maintenir

facile Ã  Ã©tendre plus tard (ex : check DB)

RÃ´le des Ã©lÃ©ments

Controller
â†’ reÃ§oit les requÃªtes HTTP

Module
â†’ regroupe les Ã©lÃ©ments liÃ©s Ã  une fonctionnalitÃ©

AppModule
â†’ module racine qui â€œdÃ©clareâ€ les autres modules

5. ChaÃ®ne complÃ¨te dâ€™une requÃªte

Quand une requÃªte arrive :

Lâ€™application dÃ©marre via main.ts

Les pipes globaux sont appliquÃ©s

NestJS trouve le bon module

Puis le controller

Puis la mÃ©thode

Une rÃ©ponse est renvoyÃ©e

ğŸ‘‰ Tout est structurÃ©, contrÃ´lÃ© et prÃ©visible

6. Bonnes pratiques Ã  retenir (rÃ©utilisables partout)

Toujours configurer la validation globalement

Toujours avoir un endpoint /health

Toujours sÃ©parer :

configuration

routes

logique

Toujours penser maintenabilitÃ© avant fonctionnalitÃ©s

7. Pourquoi cette Ã©tape est essentielle

Cette Ã©tape :

ne montre rien â€œde visibleâ€ pour lâ€™utilisateur final

mais Ã©vite Ã©normÃ©ment de bugs

et fait la diffÃ©rence entre un projet amateur et professionnel

ğŸ‘‰ Fondations solides = dÃ©veloppement plus simple ensuite

8. Phrase clÃ© Ã  retenir

Un bon backend commence par Ãªtre strict, organisÃ© et vÃ©rifiable avant dâ€™Ãªtre fonctionnel.